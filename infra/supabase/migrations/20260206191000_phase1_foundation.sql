begin;

create extension if not exists pgcrypto;
create schema if not exists app_private;

do $$
begin
  if not exists (select 1 from pg_type where typname = 'room_theme') then
    create type public.room_theme as enum ('forest', 'snow', 'coast');
  end if;

  if not exists (select 1 from pg_type where typname = 'room_status') then
    create type public.room_status as enum ('lobby', 'active', 'closed');
  end if;

  if not exists (select 1 from pg_type where typname = 'room_member_role') then
    create type public.room_member_role as enum ('host', 'guest');
  end if;
end $$;

create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  display_name text not null,
  avatar_color text not null,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint profiles_display_name_length check (char_length(display_name) between 2 and 40),
  constraint profiles_avatar_color_format check (avatar_color ~* '^#[0-9A-F]{6}$')
);

create table if not exists public.rooms (
  id uuid primary key default gen_random_uuid(),
  host_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  theme public.room_theme not null,
  seed text not null,
  status public.room_status not null default 'lobby',
  invite_token uuid not null unique default gen_random_uuid(),
  password_hash text not null,
  max_players smallint not null default 5,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  deleted_at timestamptz,
  constraint rooms_name_length check (char_length(name) between 3 and 64),
  constraint rooms_seed_not_empty check (char_length(trim(seed)) > 0),
  constraint rooms_password_hash_not_empty check (char_length(password_hash) > 0),
  constraint rooms_max_players_is_fixed check (max_players = 5)
);

create table if not exists public.room_members (
  room_id uuid not null references public.rooms(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role public.room_member_role not null,
  joined_at timestamptz not null default timezone('utc', now()),
  primary key (room_id, user_id)
);

create table if not exists app_private.join_attempts (
  id bigint generated by default as identity primary key,
  room_id uuid not null references public.rooms(id) on delete cascade,
  attempt_key text not null,
  ip_address text,
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_rooms_host_active
  on public.rooms (host_id)
  where deleted_at is null;

create index if not exists idx_room_members_user
  on public.room_members (user_id);

create index if not exists idx_room_members_role
  on public.room_members (room_id, role);

create index if not exists idx_join_attempts_room_key_time
  on app_private.join_attempts (room_id, attempt_key, created_at desc);

create or replace function app_private.touch_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = timezone('utc', now());
  return new;
end;
$$;

create or replace function app_private.enforce_world_cap()
returns trigger
language plpgsql
as $$
declare
  existing_worlds integer;
begin
  select count(*)
    into existing_worlds
    from public.rooms
   where host_id = new.host_id
     and deleted_at is null;

  if existing_worlds >= 3 then
    raise exception using
      errcode = 'P0001',
      message = 'world_cap_reached';
  end if;

  return new;
end;
$$;

create or replace function app_private.ensure_host_membership()
returns trigger
language plpgsql
as $$
begin
  insert into public.room_members (room_id, user_id, role)
  values (new.id, new.host_id, 'host')
  on conflict (room_id, user_id) do update set role = 'host';

  return new;
end;
$$;

create or replace function public.handle_new_user()
returns trigger
security definer
set search_path = public
language plpgsql
as $$
declare
  base_name text;
  normalized_name text;
begin
  base_name := coalesce(nullif(split_part(coalesce(new.email, ''), '@', 1), ''), 'player');

  if char_length(base_name) < 2 then
    normalized_name := (base_name || '_x');
  else
    normalized_name := base_name;
  end if;

  normalized_name := left(normalized_name, 40);

  insert into public.profiles (user_id, display_name, avatar_color)
  values (
    new.id,
    normalized_name,
    ('#' || substring(md5(new.id::text), 1, 6))
  )
  on conflict (user_id) do nothing;

  return new;
end;
$$;

drop trigger if exists trg_profiles_touch_updated_at on public.profiles;
create trigger trg_profiles_touch_updated_at
before update on public.profiles
for each row
execute function app_private.touch_updated_at();

drop trigger if exists trg_rooms_touch_updated_at on public.rooms;
create trigger trg_rooms_touch_updated_at
before update on public.rooms
for each row
execute function app_private.touch_updated_at();

drop trigger if exists trg_rooms_world_cap on public.rooms;
create trigger trg_rooms_world_cap
before insert on public.rooms
for each row
execute function app_private.enforce_world_cap();

drop trigger if exists trg_rooms_host_member on public.rooms;
create trigger trg_rooms_host_member
after insert on public.rooms
for each row
execute function app_private.ensure_host_membership();

drop trigger if exists trg_auth_user_created on auth.users;
create trigger trg_auth_user_created
after insert on auth.users
for each row
execute function public.handle_new_user();

alter table public.profiles enable row level security;
alter table public.rooms enable row level security;
alter table public.room_members enable row level security;

create policy "profiles_select_visible_to_room_members"
  on public.profiles
  for select
  using (
    auth.uid() = user_id
    or exists (
      select 1
        from public.room_members viewer
        join public.room_members target
          on target.room_id = viewer.room_id
       where viewer.user_id = auth.uid()
         and target.user_id = profiles.user_id
    )
  );

create policy "profiles_insert_self"
  on public.profiles
  for insert
  with check (auth.uid() = user_id);

create policy "profiles_update_self"
  on public.profiles
  for update
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "rooms_select_members_only"
  on public.rooms
  for select
  using (
    host_id = auth.uid()
    or exists (
      select 1
        from public.room_members membership
       where membership.room_id = rooms.id
         and membership.user_id = auth.uid()
    )
  );

create policy "rooms_insert_host_only"
  on public.rooms
  for insert
  with check (host_id = auth.uid());

create policy "rooms_update_host_only"
  on public.rooms
  for update
  using (host_id = auth.uid())
  with check (host_id = auth.uid());

create policy "rooms_delete_host_only"
  on public.rooms
  for delete
  using (host_id = auth.uid());

create policy "room_members_select_for_members"
  on public.room_members
  for select
  using (
    exists (
      select 1
        from public.room_members viewer
       where viewer.room_id = room_members.room_id
         and viewer.user_id = auth.uid()
    )
  );

create policy "room_members_insert_host_only"
  on public.room_members
  for insert
  with check (
    exists (
      select 1
        from public.rooms room_owner
       where room_owner.id = room_members.room_id
         and room_owner.host_id = auth.uid()
    )
  );

create policy "room_members_update_host_only"
  on public.room_members
  for update
  using (
    exists (
      select 1
        from public.rooms room_owner
       where room_owner.id = room_members.room_id
         and room_owner.host_id = auth.uid()
    )
  )
  with check (
    exists (
      select 1
        from public.rooms room_owner
       where room_owner.id = room_members.room_id
         and room_owner.host_id = auth.uid()
    )
  );

create policy "room_members_delete_host_or_self"
  on public.room_members
  for delete
  using (
    auth.uid() = user_id
    or exists (
      select 1
        from public.rooms room_owner
       where room_owner.id = room_members.room_id
         and room_owner.host_id = auth.uid()
    )
  );

grant usage on schema public to anon, authenticated;

grant select, insert, update
  on public.profiles
  to authenticated;

grant select, insert, update, delete
  on public.rooms
  to authenticated;

grant select, insert, update, delete
  on public.room_members
  to authenticated;

revoke all on schema app_private from public, anon, authenticated;
revoke all on all tables in schema app_private from anon, authenticated;
grant usage on schema app_private to service_role;
grant select, insert, delete on app_private.join_attempts to service_role;

commit;
